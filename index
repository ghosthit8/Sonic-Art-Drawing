<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Sonic Art Pad</title>
  <style>
    :root{
      --bg:#050608; --fg:#d9ffe2; --neon:#39ff88; --muted:#7ccf9a;
      --panel:#0b0f0c; --border:#1b2a22; --danger:#ff4d4d;
    }
    *{box-sizing:border-box; touch-action:none;}
    body{
      margin:0; background:radial-gradient(1200px 800px at 20% 20%, #09130d, var(--bg));
      color:var(--fg); font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    }
    header{
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      padding:12px 14px; border-bottom:1px solid var(--border);
      position:sticky; top:0; background:linear-gradient(180deg, rgba(5,6,8,.98), rgba(5,6,8,.88));
      z-index:5;
    }
    header .title{display:flex; gap:10px; align-items:baseline; flex-wrap:wrap}
    header b{color:var(--neon); letter-spacing:.6px}
    header small{color:var(--muted)}
    .wrap{
      display:grid; gap:12px; padding:12px; max-width:1280px; margin:0 auto;
      grid-template-columns: 1fr 360px;
    }
    @media (max-width: 980px){
      .wrap{grid-template-columns:1fr}
    }

    .stage{
      border:1px solid var(--border);
      background:linear-gradient(180deg, rgba(10,18,14,.6), rgba(5,6,8,.9));
      border-radius:14px;
      overflow:hidden;
      position:relative;
      min-height:520px;
      box-shadow:0 10px 30px rgba(0,0,0,.35);
    }
    canvas{display:block; width:100%; height:100%;}
    .overlay{
      position:absolute; inset:0;
      pointer-events:none;
      background:
        repeating-linear-gradient(0deg, rgba(57,255,136,.06) 0 1px, rgba(0,0,0,0) 1px 4px),
        radial-gradient(800px 500px at 60% 30%, rgba(57,255,136,.06), transparent 60%);
      mix-blend-mode:screen;
      opacity:.9;
    }
    .hud{
      position:absolute; left:12px; bottom:12px;
      padding:10px 12px; border:1px solid var(--border); border-radius:12px;
      background:rgba(5,6,8,.65); backdrop-filter: blur(6px);
      font-size:12px; line-height:1.25;
      max-width:min(520px, calc(100% - 24px));
    }
    .hud .row{display:flex; gap:10px; flex-wrap:wrap}
    .pill{
      display:inline-flex; gap:8px; align-items:center;
      border:1px solid var(--border); border-radius:999px;
      padding:6px 10px; color:var(--muted);
    }
    .pill i{color:var(--neon); font-style:normal}

    .panel{
      border:1px solid var(--border); border-radius:14px;
      background:linear-gradient(180deg, rgba(11,15,12,.9), rgba(5,6,8,.95));
      box-shadow:0 10px 30px rgba(0,0,0,.35);
      overflow:hidden;
    }
    .panel h2{
      margin:0; padding:12px 14px; font-size:14px;
      border-bottom:1px solid var(--border);
      letter-spacing:.5px;
      display:flex; justify-content:space-between; align-items:center;
    }
    .panel h2 span{color:var(--muted); font-weight:600}
    .controls{padding:12px 14px; display:grid; gap:12px}
    .grid2{display:grid; grid-template-columns: 1fr 1fr; gap:10px}
    .grid3{display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px}
    label{display:grid; gap:6px; font-size:12px; color:var(--muted)}
    input[type="range"]{width:100%}
    select, button{
      width:100%;
      background:#070a08; color:var(--fg);
      border:1px solid var(--border);
      border-radius:10px;
      padding:10px 10px;
      font-size:13px;
    }
    button{
      cursor:pointer;
      transition: transform .06s ease, border-color .15s ease;
    }
    button:active{transform:translateY(1px)}
    button.primary{border-color:rgba(57,255,136,.7)}
    button.danger{border-color:rgba(255,77,77,.6); color:#ffd0d0}
    .hint{
      color:var(--muted); font-size:12px; line-height:1.35;
      border-top:1px solid var(--border);
      padding:10px 14px;
    }
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
    .tiny{font-size:11px}
  </style>
</head>
<body>
  <header>
    <div class="title">
      <b>SONIC ART PAD</b>
      <small>draw → noisy synth reacts to space</small>
    </div>
    <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
      <button id="startBtn" class="primary" style="width:auto;padding:10px 14px;">Start Audio</button>
      <button id="clearBtn" style="width:auto;padding:10px 14px;">Clear</button>
      <button id="saveBtn" style="width:auto;padding:10px 14px;">Save PNG</button>
    </div>
  </header>

  <div class="wrap">
    <div class="stage" id="stage">
      <canvas id="c"></canvas>
      <div class="overlay"></div>
      <div class="hud" id="hud">
        <div class="row">
          <span class="pill"><i>freq</i> <span class="mono" id="hudFreq">—</span> Hz</span>
          <span class="pill"><i>cutoff</i> <span class="mono" id="hudCut">—</span> Hz</span>
          <span class="pill"><i>noise</i> <span class="mono" id="hudNoise">—</span></span>
          <span class="pill"><i>drive</i> <span class="mono" id="hudDrive">—</span></span>
        </div>
        <div class="row" style="margin-top:8px">
          <span class="pill"><i>x</i> <span class="mono" id="hudX">—</span></span>
          <span class="pill"><i>y</i> <span class="mono" id="hudY">—</span></span>
          <span class="pill"><i>speed</i> <span class="mono" id="hudSpd">—</span></span>
          <span class="pill"><i>pressure</i> <span class="mono" id="hudPrs">—</span></span>
        </div>
        <div class="tiny" style="margin-top:8px;color:var(--muted)">
          Tip: fast strokes = more grit. Left→right changes pitch. Up→down changes brightness.
        </div>
      </div>
    </div>

    <div class="panel">
      <h2>
        Synth Controls
        <span class="mono" id="audioState">audio: off</span>
      </h2>

      <div class="controls">
        <div class="grid2">
          <label>
            Waveform
            <select id="waveSel">
              <option value="sawtooth" selected>Saw (aggressive)</option>
              <option value="square">Square (buzzy)</option>
              <option value="triangle">Triangle (soft)</option>
              <option value="sine">Sine (clean)</option>
            </select>
          </label>
          <label>
            Scale Quantize
            <select id="scaleSel">
              <option value="off" selected>Off (continuous)</option>
              <option value="minor">Minor (moody)</option>
              <option value="phrygian">Phrygian (dark)</option>
              <option value="pentatonic">Pentatonic</option>
            </select>
          </label>
        </div>

        <div class="grid2">
          <label>
            Master Volume
            <input id="vol" type="range" min="0" max="1" step="0.001" value="0.55" />
          </label>
          <label>
            Glide (portamento)
            <input id="glide" type="range" min="0" max="0.25" step="0.001" value="0.035" />
          </label>
        </div>

        <div class="grid2">
          <label>
            Noise Mix
            <input id="noiseMix" type="range" min="0" max="1" step="0.001" value="0.35" />
          </label>
          <label>
            Drive (distortion)
            <input id="drive" type="range" min="0" max="1" step="0.001" value="0.35" />
          </label>
        </div>

        <div class="grid2">
          <label>
            Filter Resonance (Q)
            <input id="q" type="range" min="0.1" max="20" step="0.1" value="6" />
          </label>
          <label>
            Brightness Range
            <input id="bright" type="range" min="0" max="1" step="0.001" value="0.85" />
          </label>
        </div>

        <div class="grid2">
          <label>
            Attack
            <input id="atk" type="range" min="0.001" max="0.2" step="0.001" value="0.01" />
          </label>
          <label>
            Release
            <input id="rel" type="range" min="0.02" max="0.6" step="0.001" value="0.14" />
          </label>
        </div>

        <div class="grid2">
          <label>
            Reverb (space)
            <input id="rev" type="range" min="0" max="1" step="0.001" value="0.25" />
          </label>
          <label>
            Stereo Spread
            <input id="pan" type="range" min="0" max="1" step="0.001" value="0.65" />
          </label>
        </div>

        <div class="grid3">
          <button id="modeHold" class="primary">Mode: Hold</button>
          <button id="modeDraw">Mode: Draw</button>
          <button id="muteBtn" class="danger">Mute</button>
        </div>
      </div>

      <div class="hint">
        <div><b style="color:var(--neon)">Modes:</b> <span class="mono">Draw</span> plays only while drawing. <span class="mono">Hold</span> keeps sound running and you “scrub” the synth by moving.</div>
        <div class="tiny" style="margin-top:6px">GitHub Pages friendly. No libraries. WebAudio only.</div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== Canvas setup =====
  const canvas = document.getElementById('c');
  const stage = document.getElementById('stage');
  const ctx2d = canvas.getContext('2d', { alpha: true });

  function resizeCanvas(){
    const r = stage.getBoundingClientRect();
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    canvas.width = Math.floor(r.width * dpr);
    canvas.height = Math.floor(r.height * dpr);
    canvas.style.width = r.width + "px";
    canvas.style.height = r.height + "px";
    ctx2d.setTransform(dpr,0,0,dpr,0,0);

    // subtle grid
    ctx2d.clearRect(0,0,r.width,r.height);
    ctx2d.save();
    ctx2d.globalAlpha = 0.18;
    ctx2d.strokeStyle = "#39ff88";
    ctx2d.lineWidth = 1;
    const step = 32;
    for(let x=0; x<r.width; x+=step){
      ctx2d.beginPath(); ctx2d.moveTo(x,0); ctx2d.lineTo(x,r.height); ctx2d.stroke();
    }
    for(let y=0; y<r.height; y+=step){
      ctx2d.beginPath(); ctx2d.moveTo(0,y); ctx2d.lineTo(r.width,y); ctx2d.stroke();
    }
    ctx2d.restore();
  }
  window.addEventListener('resize', resizeCanvas, {passive:true});
  resizeCanvas();

  // drawing state
  let drawing = false;
  let lastPt = null;
  let lastT = 0;

  function drawStroke(p){
    const w = stage.getBoundingClientRect().width;
    const h = stage.getBoundingClientRect().height;

    const x = p.x, y = p.y;
    const speed = p.speed || 0;
    const pressure = p.pressure ?? 0.5;

    // neon brush
    ctx2d.save();
    ctx2d.globalCompositeOperation = "lighter";
    ctx2d.strokeStyle = `rgba(57,255,136,${0.20 + 0.55*pressure})`;
    ctx2d.lineWidth = 1.5 + (pressure*8) + Math.min(10, speed*0.02);
    ctx2d.lineCap = "round";
    ctx2d.lineJoin = "round";

    // glow pass
    ctx2d.shadowColor = "rgba(57,255,136,0.55)";
    ctx2d.shadowBlur = 12;

    if(lastPt){
      ctx2d.beginPath();
      ctx2d.moveTo(lastPt.x, lastPt.y);
      ctx2d.lineTo(x, y);
      ctx2d.stroke();
    } else {
      ctx2d.beginPath();
      ctx2d.arc(x, y, 2 + pressure*6, 0, Math.PI*2);
      ctx2d.fillStyle = "rgba(57,255,136,0.35)";
      ctx2d.fill();
    }
    ctx2d.restore();

    lastPt = {x,y};
  }

  // ===== WebAudio synth =====
  let ac = null;
  let master = null;
  let osc = null;
  let noiseSrc = null;
  let noiseGain = null;
  let oscGain = null;
  let filter = null;
  let shaper = null;
  let convolver = null;
  let revGain = null;
  let dryGain = null;
  let panner = null;

  let muted = false;
  let mode = "hold"; // "draw" | "hold"
  let gateOn = false;

  // UI refs
  const ui = {
    startBtn: document.getElementById('startBtn'),
    clearBtn: document.getElementById('clearBtn'),
    saveBtn: document.getElementById('saveBtn'),
    waveSel: document.getElementById('waveSel'),
    scaleSel: document.getElementById('scaleSel'),
    vol: document.getElementById('vol'),
    glide: document.getElementById('glide'),
    noiseMix: document.getElementById('noiseMix'),
    drive: document.getElementById('drive'),
    q: document.getElementById('q'),
    bright: document.getElementById('bright'),
    atk: document.getElementById('atk'),
    rel: document.getElementById('rel'),
    rev: document.getElementById('rev'),
    pan: document.getElementById('pan'),
    modeHold: document.getElementById('modeHold'),
    modeDraw: document.getElementById('modeDraw'),
    muteBtn: document.getElementById('muteBtn'),
    audioState: document.getElementById('audioState'),
  };

  const hud = {
    f: document.getElementById('hudFreq'),
    c: document.getElementById('hudCut'),
    n: document.getElementById('hudNoise'),
    d: document.getElementById('hudDrive'),
    x: document.getElementById('hudX'),
    y: document.getElementById('hudY'),
    s: document.getElementById('hudSpd'),
    p: document.getElementById('hudPrs'),
  };

  function setAudioStateLabel(){
    const st = ac ? ac.state : "off";
    ui.audioState.textContent = `audio: ${st}${muted ? " (muted)" : ""}`;
  }

  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
  function lerp(a,b,t){ return a + (b-a)*t; }

  function makeNoiseBuffer(ctx, seconds=2){
    const sr = ctx.sampleRate;
    const len = Math.floor(sr * seconds);
    const buf = ctx.createBuffer(1, len, sr);
    const data = buf.getChannelData(0);
    // slightly "crunchy" pink-ish noise
    let b0=0,b1=0,b2=0,b3=0,b4=0,b5=0,b6=0;
    for(let i=0;i<len;i++){
      const white = Math.random()*2-1;
      b0 = 0.99886*b0 + white*0.0555179;
      b1 = 0.99332*b1 + white*0.0750759;
      b2 = 0.96900*b2 + white*0.1538520;
      b3 = 0.86650*b3 + white*0.3104856;
      b4 = 0.55000*b4 + white*0.5329522;
      b5 = -0.7616*b5 - white*0.0168980;
      const pink = b0+b1+b2+b3+b4+b5+b6 + white*0.5362;
      b6 = white*0.115926;
      data[i] = clamp(pink*0.14, -1, 1);
    }
    return buf;
  }

  function makeReverbIR(ctx, seconds=1.3, decay=2.2){
    const sr = ctx.sampleRate;
    const len = Math.floor(sr * seconds);
    const ir = ctx.createBuffer(2, len, sr);
    for(let ch=0; ch<2; ch++){
      const d = ir.getChannelData(ch);
      for(let i=0; i<len; i++){
        const t = i/len;
        const env = Math.pow(1 - t, decay);
        d[i] = (Math.random()*2-1) * env;
      }
    }
    return ir;
  }

  function makeWaveshaper(ctx, amount=0.35){
    const n = 2048;
    const curve = new Float32Array(n);
    const k = 1 + amount*60;
    for(let i=0;i<n;i++){
      const x = (i*2/n)-1;
      curve[i] = ((1 + k) * x) / (1 + k * Math.abs(x));
    }
    return curve;
  }

  function initAudio(){
    if(ac) return;

    ac = new (window.AudioContext || window.webkitAudioContext)();

    master = ac.createGain();
    master.gain.value = ui.vol.value;

    // main osc
    osc = ac.createOscillator();
    osc.type = ui.waveSel.value;
    osc.frequency.value = 220;

    oscGain = ac.createGain();
    oscGain.gain.value = 0.0;

    // noise
    noiseSrc = ac.createBufferSource();
    noiseSrc.buffer = makeNoiseBuffer(ac, 3.0);
    noiseSrc.loop = true;

    noiseGain = ac.createGain();
    noiseGain.gain.value = ui.noiseMix.value * 0.25;

    // filter
    filter = ac.createBiquadFilter();
    filter.type = "lowpass";
    filter.frequency.value = 1400;
    filter.Q.value = ui.q.value;

    // distortion
    shaper = ac.createWaveShaper();
    shaper.oversample = "4x";
    shaper.curve = makeWaveshaper(ac, parseFloat(ui.drive.value));

    // stereo
    panner = ac.createStereoPanner();
    panner.pan.value = 0;

    // reverb
    convolver = ac.createConvolver();
    convolver.buffer = makeReverbIR(ac, 1.35, 2.3);
    revGain = ac.createGain();
    dryGain = ac.createGain();
    revGain.gain.value = ui.rev.value;
    dryGain.gain.value = 1 - ui.rev.value;

    // routing
    osc.connect(oscGain);
    noiseSrc.connect(noiseGain);

    const mix = ac.createGain();
    oscGain.connect(mix);
    noiseGain.connect(mix);

    mix.connect(filter);
    filter.connect(shaper);
    shaper.connect(panner);

    // dry/wet
    panner.connect(dryGain);
    panner.connect(convolver);
    convolver.connect(revGain);

    dryGain.connect(master);
    revGain.connect(master);

    master.connect(ac.destination);

    osc.start();
    noiseSrc.start();

    setAudioStateLabel();
  }

  async function ensureAudioRunning(){
    initAudio();
    if(ac.state !== "running"){
      await ac.resume();
    }
    setAudioStateLabel();
  }

  function gate(on, velocity=1){
    if(!ac) return;

    const now = ac.currentTime;
    const atk = parseFloat(ui.atk.value);
    const rel = parseFloat(ui.rel.value);

    const target = muted ? 0 : (0.22 + 0.78*velocity); // internal base
    if(on){
      if(gateOn) return;
      gateOn = true;
      oscGain.gain.cancelScheduledValues(now);
      oscGain.gain.setValueAtTime(oscGain.gain.value, now);
      oscGain.gain.linearRampToValueAtTime(target, now + atk);
    } else {
      if(!gateOn) return;
      gateOn = false;
      oscGain.gain.cancelScheduledValues(now);
      oscGain.gain.setValueAtTime(oscGain.gain.value, now);
      oscGain.gain.linearRampToValueAtTime(0.0, now + rel);
    }
  }

  const SCALES = {
    minor:      [0,2,3,5,7,8,10],
    phrygian:   [0,1,3,5,7,8,10],
    pentatonic: [0,2,4,7,9]
  };

  function quantizeToScale(freq, scaleName){
    if(scaleName === "off") return freq;
    // map freq to MIDI, snap to nearest scale step in current octave
    const midi = 69 + 12*Math.log2(freq/440);
    const root = 48; // C3-ish base
    const rel = midi - root;
    const octave = Math.floor(rel/12);
    const noteInOct = ((rel%12)+12)%12;
    const steps = SCALES[scaleName] || SCALES.minor;

    let best = steps[0], bestDist = 999;
    for(const s of steps){
      const d = Math.abs(s - noteInOct);
      if(d < bestDist){ bestDist = d; best = s; }
    }
    const snapped = root + octave*12 + best;
    return 440 * Math.pow(2, (snapped - 69)/12);
  }

  function updateSynthFromPoint(p){
    if(!ac) return;

    const rect = stage.getBoundingClientRect();
    const nx = clamp(p.x / rect.width, 0, 1);
    const ny = clamp(p.y / rect.height, 0, 1);

    const speed = clamp(p.speed || 0, 0, 2500); // px/sec
    const spNorm = clamp(speed / 1800, 0, 1);

    const pressure = clamp((p.pressure ?? 0.5), 0, 1);

    // Base freq range (left->right): 60 Hz .. 1200 Hz (noisy synth zone)
    let freq = 60 * Math.pow(1200/60, nx);
    freq = quantizeToScale(freq, ui.scaleSel.value);

    // Filter cutoff (top bright, bottom dark)
    const brightAmt = parseFloat(ui.bright.value);
    const cutoffMin = 120;
    const cutoffMax = lerp(1800, 9000, brightAmt);
    const cutoff = cutoffMin * Math.pow(cutoffMax/cutoffMin, 1 - ny);

    // noise & drive react to speed (fast strokes = gritty)
    const baseNoise = parseFloat(ui.noiseMix.value);
    const baseDrive = parseFloat(ui.drive.value);
    const noiseAmt = clamp(baseNoise * (0.55 + 1.15*spNorm), 0, 1);
    const driveAmt = clamp(baseDrive * (0.55 + 1.4*spNorm), 0, 1);

    // pan spreads with x
    const spread = parseFloat(ui.pan.value);
    const pan = (nx*2 - 1) * spread;

    // Apply with glide
    const now = ac.currentTime;
    const glide = parseFloat(ui.glide.value);

    osc.frequency.cancelScheduledValues(now);
    osc.frequency.setValueAtTime(osc.frequency.value, now);
    osc.frequency.exponentialRampToValueAtTime(freq, now + Math.max(0.001, glide));

    filter.frequency.cancelScheduledValues(now);
    filter.frequency.setValueAtTime(filter.frequency.value, now);
    filter.frequency.exponentialRampToValueAtTime(cutoff, now + 0.015);

    filter.Q.setTargetAtTime(parseFloat(ui.q.value), now, 0.01);

    // mix levels
    noiseGain.gain.setTargetAtTime(noiseAmt * 0.32, now, 0.02);

    // drive updates waveshaper curve
    shaper.curve = makeWaveshaper(ac, driveAmt);

    // volume influenced by pressure (if supported)
    // if draw mode, gate does envelope; in hold mode, gate always on unless muted
    const vel = 0.25 + 0.75*pressure;
    if(mode === "hold"){
      // keep a gentle base so it doesn't jump
      oscGain.gain.setTargetAtTime(muted ? 0 : (0.08 + 0.55*vel), now, 0.03);
      gateOn = true;
    } else {
      // draw mode uses gate() for envelope; velocity handled there
      if(drawing) {
        // nudge target quickly while held
        oscGain.gain.setTargetAtTime(muted ? 0 : (0.18 + 0.75*vel), now, 0.02);
      }
    }

    panner.pan.setTargetAtTime(pan, now, 0.02);

    // reverb mix
    const rv = parseFloat(ui.rev.value);
    revGain.gain.setTargetAtTime(rv, now, 0.04);
    dryGain.gain.setTargetAtTime(1 - rv, now, 0.04);

    // master volume
    master.gain.setTargetAtTime(muted ? 0 : parseFloat(ui.vol.value), now, 0.02);

    // HUD
    hud.f.textContent = freq.toFixed(1);
    hud.c.textContent = cutoff.toFixed(0);
    hud.n.textContent = noiseAmt.toFixed(2);
    hud.d.textContent = driveAmt.toFixed(2);
    hud.x.textContent = nx.toFixed(3);
    hud.y.textContent = ny.toFixed(3);
    hud.s.textContent = speed.toFixed(0);
    hud.p.textContent = pressure.toFixed(2);
  }

  // ===== Pointer handling =====
  function getPoint(e){
    const rect = stage.getBoundingClientRect();
    const x = (e.clientX - rect.left);
    const y = (e.clientY - rect.top);

    const t = performance.now();
    let speed = 0;
    if(lastPt){
      const dt = Math.max(1, t - lastT);
      const dx = x - lastPt.x;
      const dy = y - lastPt.y;
      speed = Math.sqrt(dx*dx + dy*dy) / (dt/1000); // px/sec
    }
    lastT = t;

    const pressure = (typeof e.pressure === "number" && e.pressure > 0) ? e.pressure : 0.5;
    return { x, y, speed, pressure };
  }

  stage.addEventListener('pointerdown', async (e) => {
    e.preventDefault();
    stage.setPointerCapture(e.pointerId);
    await ensureAudioRunning();

    drawing = true;
    lastPt = null;
    lastT = performance.now();

    const p = getPoint(e);
    drawStroke(p);
    updateSynthFromPoint(p);

    if(mode === "draw"){
      gate(true, 0.25 + 0.75*(p.pressure ?? 0.5));
    } else {
      // hold mode: keep running
      gateOn = true;
      oscGain.gain.setTargetAtTime(muted ? 0 : 0.18, ac.currentTime, 0.02);
    }
  }, {passive:false});

  stage.addEventListener('pointermove', (e) => {
    if(!drawing && mode !== "hold") return;
    e.preventDefault();
    const p = getPoint(e);

    if(drawing) drawStroke(p);
    updateSynthFromPoint(p);
  }, {passive:false});

  function endDraw(){
    drawing = false;
    lastPt = null;
    if(mode === "draw"){
      gate(false);
    }
  }

  stage.addEventListener('pointerup', (e) => { e.preventDefault(); endDraw(); }, {passive:false});
  stage.addEventListener('pointercancel', (e) => { e.preventDefault(); endDraw(); }, {passive:false});
  stage.addEventListener('pointerleave', (e) => { if(mode==="draw") endDraw(); }, {passive:true});

  // ===== UI wiring =====
  ui.startBtn.addEventListener('click', async () => {
    await ensureAudioRunning();
  });

  ui.clearBtn.addEventListener('click', () => {
    resizeCanvas();
  });

  ui.saveBtn.addEventListener('click', () => {
    const a = document.createElement('a');
    a.download = `sonic-art-${Date.now()}.png`;
    a.href = canvas.toDataURL('image/png');
    a.click();
  });

  ui.waveSel.addEventListener('change', () => {
    if(osc) osc.type = ui.waveSel.value;
  });

  ui.muteBtn.addEventListener('click', () => {
    muted = !muted;
    ui.muteBtn.textContent = muted ? "Unmute" : "Mute";
    setAudioStateLabel();
    if(ac && master){
      master.gain.setTargetAtTime(muted ? 0 : parseFloat(ui.vol.value), ac.currentTime, 0.03);
    }
  });

  ui.modeHold.addEventListener('click', () => {
    mode = "hold";
    ui.modeHold.classList.add('primary');
    ui.modeDraw.classList.remove('primary');
    if(ac) {
      // gentle base if unmuted
      oscGain.gain.setTargetAtTime(muted ? 0 : 0.12, ac.currentTime, 0.02);
      gateOn = true;
    }
  });
  ui.modeDraw.addEventListener('click', () => {
    mode = "draw";
    ui.modeDraw.classList.add('primary');
    ui.modeHold.classList.remove('primary');
    if(ac && !drawing){
      oscGain.gain.setTargetAtTime(0.0, ac.currentTime, 0.02);
      gateOn = false;
    }
  });

  // make hold default button look active
  ui.modeHold.classList.add('primary');

  // keep label updated
  document.addEventListener('visibilitychange', () => {
    if(ac) setAudioStateLabel();
  });

  // If audio context created, listen for state changes
  const poll = setInterval(() => {
    if(ac) setAudioStateLabel();
  }, 700);

})();
</script>
</body>
</html>
